# 数据结构笔记



## （一）预备知识

### 动态内存管理的用法

需要include<stdlib.h>

有两个函数需要使用，malloc与free

例子：

```c
char *s;
int *intptr;
s = (char *)malloc(32); /* s指向大小为32个字节（字符）的空间*/
s = (char *)malloc(strlen(p)+1);/* s指向能正好存放字符串p的空间*/
intptr = (int *)malloc(sizeof(int)*10);/* ptr指向能存放10个整型元素的空间*/
//在结构体中的用法在下面
```

### 结构体

定义方式可以有两种：

```c++
//第一种(都以链表为例)
struct Node{
    int data;
    struct Node* next;
}
//第二种（使用typedef）
typedef struct Node{
    int data;
    struct Node* next;//因为还没有typedef下面的名称，故不能直接使用LinkNode*
}LinkNode;
```

如果需要在函数中新建一个链表单元，可使用

```c++
struct Node s=(struct Node*)malloc(sizeof(struct Node));//依据第一种定义
LinkNode s=(LinkNode*)malloc(sizeof(LinkNode));//依据第二种定义
```

### 对指针的几点说明

#### （1）指针的运算

1. 指针与整数加减 `p+n; p-n;`也可以`p++; p+=2;`

2. 指针赋值 可使两个指针指向同一对象

   ```c++
   int* p=s->next;
   int* q=p;
   ```

3. 指针比较 实质上是地址的比较

4. 两指针相减=相差元素的个数

*注意：两指针不能相加！*

#### （2）指针与数组

数组名即指向该数组第一个元素（下标为0）的指针。

但前者是常量，后者是变量。

指针可以按数组的形式访问。

```c++
//例子
char a[]="hello";
printf("%c\n",a[0]);   //'h'
printf("%s\n",a+2); //'llo'
//a=a+2;   error:a为常数，无法被赋值。
char* p=a;
int i=5;
while(i--)
   cout<<p++<<endl;//hello ello llo lo o
while(*p--)
   cout<<*p<<endl;//hello ello llo lo o
```

##### (注)字符型常量

举例：char *n="hello"和char a[]="hello"的区别？

​		n为字符型变量，内容为一个地址，指向位于文字常量区的“hello”，此时“hello”在内存中只有一份拷贝；

​		a是一个位于栈上的有6个元素（含字符串末尾的空字符）的数组，并将“hello”拷贝到它所占的内存中，此时“hello”有两份拷贝。

![](G:\college\大一下\数据结构\笔记\photo\QQ图片20220407202743.png)

![](G:\college\大一下\数据结构\笔记\photo\QQ图片20220407202824.png)

## (二)线性表

### 顺序表

构建方式：

```c++
#define MAXSIZE 50
typedef char ElemType;
typedef struct {
	ElemType data[MAXSIZE];//数组实现
	int length;            //存储的数据总数量

}SqList;
```

函数声明：

```c++
void CreateList(SqList*& L, ElemType a[], int n);//创建顺序表
void InitList(SqList*& L);//初始化顺序表
void ListPrint(SqList* L);//打印表
int ListLength(SqList* L);//获取长度
void ListDestroy(SqList*& L);//摧毁表
bool ListEmpty(SqList* L);//检查是否为空
bool ListGet(SqList* L, int n, ElemType& result);//得到表某位置的数据
int ListSearch(SqList* L, ElemType a);//查找与a相等的第一个元素位置
bool ListInsert(SqList*& L, int n, ElemType f);//插入
bool ListDelete(SqList*& L, int n, ElemType& e);//删除
```

函数内容如下：

```c++
void CreateList(SqList* &L,ElemType a[],int n) {
	for (int i = 0;i < n;i++) {
		L->data[i]= a[i];
	}
	L->length = n;
}
void InitList(SqList*& L) {
	L = (SqList*)malloc(sizeof(SqList));
	L->length = 0;
}
void ListPrint(SqList* L) {
	for (int i = 0;i < L->length;i++)
		cout << L->data[i];
	cout << endl;
}
int ListLength(SqList* L) {
	return L->length;
}
void ListDestroy(SqList*& L) {
	free(L);
}
bool ListEmpty(SqList* L) {
	return (L->length==0);
}
bool ListGet(SqList* L,int n,ElemType & result) {
	if (n<1 || n>L->length)
		return false;
	result=L->data[n - 1];
	return true;
}
int ListSearch(SqList* L, ElemType a) {
	for (int i = 0;i < L->length;i++) {
		if (a == L->data[i])
			return i + 1;
		else
			return 0;
	}
}
bool ListInsert(SqList*& L, int n, ElemType f) {
	if (n<1||n>L->length+1) {
		return false;
	}
	n--;
	for (int i = L->length;i > n;i--) {
		L->data[i] = L->data[i - 1];
	}
	L->data[n] = f;
	L->length++;
	return true;
}
bool ListDelete(SqList*& L, int n, ElemType& e) {
	if (n<1 || n>L->length + 1) {
		return false;
	}
	n--;
	e = L->data[n];
	for (int i =n;i < L->length-1;i++) {
		L->data[i] = L->data[i +1];
	}
	L->length--;
	return true;
}
```

##### （注）其实本质像一个可变数组

### 单链表

构建方式：

```c++
typedef char ElemType;
typedef struct LNode {
	ElemType data;
	struct LNode* next;

}LinkNode;
```

函数声明：

```c++
void CreateNodeF(LinkNode*& L, ElemType a[], int n);//头插法
void CreateNodeR(LinkNode*& L, ElemType a[], int n);//尾插法
void InitNode(LinkNode*& L);//初始化
void NodeDestroy(LinkNode*& L);//销毁表
void NodePrint(LinkNode* L);//打印全表
int NodeLength(LinkNode* L);//表长
bool NodeEmpty(LinkNode* L);//表是否为空
bool NodeGet(LinkNode* L, int n, ElemType& result);//得到对应位置的值
int NodeSearch(LinkNode* L, ElemType a);//找到与a相同的第一个元素的位置
bool NodeInsert(LinkNode*& L, int n, ElemType f);//插入（头插）
bool NodeDelete(LinkNode*& L, int n, ElemType& e);//删除
```

函数内容：

```c++
void CreateNodeF(LinkNode*& L, ElemType a[], int n) {
	LinkNode* s;
	L=(LinkNode*)malloc(sizeof(LinkNode));//为头结点赋予地址
	L->next = NULL;//初始化
	for (int i = 0;i < n;i++) {
		s = (LinkNode*)malloc(sizeof(LinkNode));//建立一个空地址（声明s时并没有声明它所在的空地址）
		s->data = a[i];//赋值
		s->next = L->next;//让s的next指向L的next
		L->next = s;//让L的next指向s；
	}
}
```

如同：

![](G:\college\大一下\数据结构\笔记\photo\01.png)

```c++
void CreateNodeR(LinkNode*& L, ElemType a[], int n) {
	LinkNode* s,*r;
	L = (LinkNode*)malloc(sizeof(LinkNode));
	L->next = NULL;
	r = L;//让r指向L
	for (int i = 0;i < n;i++) {
		s = (LinkNode*)malloc(sizeof(LinkNode));//设置一个s，成为要插入的结点
		s->data = a[i];
		r->next = s;//让r的next指向s
		r = s;//让r的地址转移到s处
	}
	r->next = NULL;//设置尾结点指向NULL
    //注意，它仍有头结点
}
void InitNode(LinkNode*& L) {
	L = (LinkNode*)malloc(sizeof(LinkNode));
	L->next = NULL;
}
void NodeDestroy(LinkNode*& L) {
	LinkNode* temp = L, * loc = temp->next;//设置一个temp指针，指向正在删除的结点，设置loc指针，帮助temp移动
	while (loc != NULL) {//当loc移动到NULL，表示已经完全走完
		free(temp);//从头结点开始删
		temp = loc;//temp指向下一个
		loc = temp->next;//loc移动
	}
	free(temp);//释放最后一个结点
}
void NodePrint(LinkNode* L) {
	LinkNode* s=L->next;
	while (s!= NULL) {
		cout << s->data;
		s = s->next;
	}
	cout << endl;//换行
}
int NodeLength(LinkNode* L) {
	int cnt = 0;//计数器
	LinkNode* s = L;
	while (s->next != NULL) {
		cnt++;
		s = s->next;//（不算头结点）
	}
	return cnt;
}

bool NodeEmpty(LinkNode* L) {
	return (L->next ==NULL);
}
bool NodeGet(LinkNode* L, int n, ElemType& result) {
	int i = 0;
	LinkNode* s = L;
	if (n < 0) return false;
	while (i < n && s->next != NULL) {
		i++;
		s = s->next;
	}
	if (s == NULL)
		return false;
	else
		result = s->data;
	return true;
	
}
int NodeSearch(LinkNode* L, ElemType a) {
	int i = 0;
	LinkNode* s = L;
	while (s->data!=a&&s->next != NULL) {
		s = s->next;
		i++;
	}
	if (s == NULL)
		return 0;
	else
		return i;

}
bool NodeInsert(LinkNode*& L, int n, ElemType f) {
	int i = 0;
	LinkNode* s = L,*p;
	if (n < 0) return false;//判断n是否正确
	while (i<n-1 && s->next != NULL) {//寻找其位置，并防止越界
		s = s->next;
		i++;
	}
	if (s == NULL)//未找到位置
		return false;
	else {
		p = (LinkNode*)malloc(sizeof(LinkNode));//插入
		p->data = f;
		p->next = s->next;
		s->next = p;
		return true;
	}

}
bool NodeDelete(LinkNode*& L, int n, ElemType& e) {
	int i = 0;
	LinkNode* s = L, * p;
	if (n < 0) return false;
	while (i < n - 1 && s->next != NULL) {
		s = s->next;
		i++;
	}
	if (s == NULL)
		return false;
	else {
		p=s->next;
		if (s == NULL)
			return false;
		e = p->data;
		s->next = p->next;
		free(p);
		return true;
	}

}
```

### 循环单链表

在其尾结点的next直接指向头节点的地址。

![](G:\college\大一下\数据结构\笔记\photo\1649336642783.jpg)

```c++
int length(Nodeptr* list) {
	Nodeptr* p=list;
	int n=0; /* 链表的长度置初值0 */
	if(list == NULL) return 0;
	do {
		p=p->link;
		n++;
	} while(p!=list);
	return n; /* 返回链表的长度n */
}
```

注意其求长度有所差别

### 双向链表

构建方式：

```c++
typedef char ElemType;
typedef struct DNode {
	ElemType data;
	struct DNode* prior;
    struct DNode* next;
}DLinkNode;
```

部分函数：

```c++
void CreateListF(DLinkNode*&L,ElemType a[],int n){//头插法
    DLinkNode* s;
    L=(DLinkNode*)malloc(sizeof(DLinkNode));//头结点
    L->prior=L->next=NULL;//初始化
   	for(int i=0;i<n;i++){
        s=(DLinkNode*)malloc(sizeof(DLinkNode));//创建s数据结点
        s->data=a[i];
        s->next=L->next;//将s插入数据之后
        if(L->next!=NULL)//若L前面的元素存在，修改L->next的前驱指针prior
            L->next->prior=s;//前面的元素头指向s
        L->next=s;//l的next指向s
        s->prior=L;//再让s的头指向L
    }
}
```

```c++
void CreateListF(DLinkNode*&L,ElemType a[],int n){//尾插法
    DLinkNode* s,* r;
    L=(DLinkNode*)malloc(sizeof(DLinkNode));//头结点
    r=L;
   	for(int i=0;i<n;i++){
        s=(DLinkNode*)malloc(sizeof(DLinkNode));//创建s数据结点
        s->data=a[i];
        //将s插入r之后
        r->next=s;
        s->prior=r;
        //r指向尾结点
        r=s;
    }
}
```

插入时，需要如下四个语句

```c++
//s插入到p后
s->next=p->next;//s的next指向p的下一个位置
p->next->prior=s//让p下面的头指针指向s
//完成s和p后结点的联立
s->prior=p;//s的头指针指向p
p->next=s;//p的下一位指向s
//完成s和p结点的联立
```

 删除时，需要如下两个语句

```c++
p->next=q->next;
q->nesxt->prior=p;
free(p);
```

## (三)栈与队列

### 栈

#### 顺序栈

类型定义

```c++
typedef char Elemtype
define MAXSIZE 100
typedef struct {
    Elemtype data[MAXSIZE];//使用数组存储
    int top;//栈顶指针
}SqStack;
```

栈有如下性质：

- 栈空条件：s->top==-1;
- 栈满条件：s->top==MAXSIZE-1（data数组最大下标）
- 元素e的入栈操作：（1）top++；（2）e=s->data[top]；
- 出栈操作：（1）e=s->data[top]；（2）top--；

实现函数如下：

```c++
void InitStack(SqStack *&S) {//初始化
	s->base = (SqStack*)malloc(MAXSIZE*sizeof(SqStack));
	s->top=-1;
}
void DestoryStack(SqStack *&S){
    free(s);
}
bool StackEmpty(SqStack *S){
    return (s->top==-1);
}
bool Push(SqStack *&S,Elemtype e){
    if(s->top==MAXSIZE-1)return false;
    s->top++;
    s->data[s->top]=e;
    return true;
}
bool Pop(SqStack *&S,Elemtype e){
    if(s->top==-1)return false;
    e=s->data[s->top];
    s->top--;
    return true;
}
bool GetStack(SqStack *&S,Elemtype &e){
   	if(s->top==-1)return false;
    e=s->data[s->top];
    return true;
}
```



#### 链栈

构建方式（为**链表构建**方式）

函数

```c++
void InitStack(LinkNode*& s) {//初始化
	s = (LinkNode*)malloc(sizeof(LinkNode));
	s->next = NULL;
}

bool StackEmpty(LinkNode* s) {//调查是否为空
	return  (s->next == NULL);
}
void Push(LinkNode*& s, ElemType e) {//入栈
	LinkNode* p;
	p= (LinkNode*)malloc(sizeof(LinkNode));
	p->data = e;
	p->next = s->next;
	s->next = p;
}
bool Pop(LinkNode*& s, ElemType e) {//出栈
	LinkNode* p;
	if (s->next == NULL) {
		return false;
	}
	else {
		p = s->next;
		e = p->data;
		s->next = p->next;
		free(p);
		return true;
	}
}
bool GetTop(LinkNode* s, ElemType &e) {//获取第一个为e的元素
	LinkNode* p;
	if (s->next == NULL) {
		return false;
	}
	else {
		p = s->next;
		e = p->data;

		return true;
	}
}
void DestoryStack(LinkNode *&s){//摧毁栈
	LinkNode* p=s->next;
	while (p!= NULL) {
		free(s);
		s=p;
		p = p->next;
		
	}
}
```

#### 栈的应用

##### （1）走地图

```c++
include<iostream>
using namespace std;
#define M 4
#define N 4
#define MAXSIZE 100
int maze[M + 2][N + 2]={//地图初始化
	{1,1,1,1,1,1},{1,0,0,0,1,1},{1,0,1,0,0,1},
	{1,0,0,0,1,1},{1,1,0,0,0,1},{1,1,1,1,1,1}};
struct {
	int i, j;
	int di;
}st[MAXSIZE], path[MAXSIZE];       //st来存储当前路径，path存储最短路径
int top = -1;                      //栈顶指针
int cnt = 1;                     //记录路径长度
int minlen = MAXSIZE;              //记录最小路径长度
void dispapath(){
	int k;
	printf("%5d:", cnt++);
	for (k = 0;k <= top;k++) {         //输出路径
		printf("(%d,%d) ", st[k].i, st[k].j);
	}
	cout << endl;
	if (top + 1 < minlen) {            //寻找最小路径
		for (k = 0;k <= top;k++) {
			path[k] = st[k];
		}
		minlen = top + 1;
	}

}
void dispminpath() {
	cout << "最小路径：" << endl;
	cout << "长度：" <<minlen<< endl;
	cout << "路径：";
	for (int k = 0;k < minlen;k++) {
		printf("(%d,%d)", path[k].i, path[k].j);
	}
	cout << endl;
}
void pathfind(int xi,int yi,int xe,int ye) {
	int i, j, il=1, jl=1, di;
	bool find;
	top++;                   //入栈
	st[top].i = xi;
	st[top]. j = yi;
	st[top].di = -1;maze[xi][yi] = -1; //初始化数值
	while (top > -1) {
		i = st[top].i;
		j = st[top].j;
		di = st[top].di;
		if (i == xe && j == ye) {    //找到出口
			dispapath();
			maze[i][j] = 0;         //因为在寻炸路径的时候将其置零，所以需要将出口变为可走
			top--;                  //出栈
			i = st[top].i;
			j = st[top].j;
			di = st[top].di;        //栈顶变为当前方块
		}
		find = false;
		while (di < 4 && !find) {    //操作，寻找可走方块
			di++;
			switch (di) {
			case 0:il = i - 1; jl = j; break;
			case 1:il = i; jl = j + 1; break;
			case 2:il = i + 1; jl = j; break;
			case 3:il = i; jl = j - 1; break;
			}
			if (maze[il][jl] == 0)find = true;
		}
		if (find) {                //找到了可走方块
			st[top].di = di;       //修改原栈顶元素的di值
			top++;
			st[top].i = il;
			st[top].j = jl;
			st[top].di = -1;      //下一可走方块入栈
			maze[il][jl] = -1;    //将走过的路变为不可走
		}
		else {
			maze[i][j] = 0;     //没路可走，退栈，并将该位置重新设置为可走
			top--;
		}
	}
	dispminpath();             //输出最短路径
}
int main() {
	cout << "迷宫所有路径：" << endl;
	pathfind(1, 1, M, N);
	return 0;
}
```

##### （2）n皇后问题

```c++
#include<iostream>
#include<stdlib.h>
#define MAXSIZE 100
using namespace std;
typedef struct {
	int col[MAXSIZE];         //col[i]为皇后位置标识
	int top;                  //栈顶指针
}StackType;
void dispasolution(StackType st) {    //输出一个解
	static int cnt = 0;
	printf("第%d个解：",++cnt);
	for (int i = 1;i <= st.top;i++)
		printf("(%d,%d)", i, st.col[i]);
	printf("\n");
}
bool place(StackType st, int k, int j) { //遍历整个数组，看是否有冲突
	int i = 1;
	if (k == 1)return true;             //放一个皇后
	while (i <= k - 1) {                //看是否与前面的皇后有冲突
		if ((st.col[i] == j) || (abs(j - st.col[i]) == abs(i - k)))
			return false;
		i++;
	}
	return true;
}
void queen(int n) {
	int k;
	bool find;
	StackType st;
	st.top = 0;                     //从第一行开始，初始标号为0
	st.top++;
	st.col[st.top] = 0;            //表示从栈顶的皇后开始
	while (st.top!=0) {            //栈不空时遍历循环
		k = st.top;
		find = false;
		for (int j = st.col[k] + 1;j <= n;j++)   //寻找合适标号
			if (place(st, k, j)) {               //将其位置（i，j）拿去place中测试
				st.col[st.top] = j;
				find = true;
				break;
			}
			if (find) {                  //如果找到位置
				if (k == n)             //全找到直接输出
					dispasolution(st);  
				else {
					st.top++;          //还没找完先入栈
					st.col[st.top] = 0;//新入栈的皇后从第0列开始重新测试
				}
			}
			else {
				st.top--;                //皇后位置不合适，则回溯。
			}
		}
	}
int main() {
	int n;
	printf("皇后问题（n<20）n=");
	cin >> n;
	if (n > 20) {
		printf("n过大\n");

	}
	else {
		printf("解法如下：\n");
		queen(n);
	}
}
```

